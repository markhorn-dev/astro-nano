---
title: "Automatyczne labelkowanie Pull Requesta w Githubie"
date: "2025-01-20"
categories: 
  - "javascript"
tags: 
  - "rozwÃ³j"
  - "javascript"
  - "self-develop"
  - "github"
  - "automatyzacja"
author:
   name: Marek Szkudelski
   picture: '/assets/blog/authors/face.png'
ogImage:
 url: ''
level: ""
published: 'true'
description: 'Odkryj jak zautomatyzowaÄ‡ proces labelkowania Pull RequestÃ³w w GitHubie przy uÅ¼yciu Actions i JavaScript. RozwiÄ…zanie automatycznie okreÅ›la zmianÄ™ wersji semantycznej na podstawie Conventional Commits i dodaje odpowiednie labelki - oszczÄ™dzajÄ…c czas i redukujÄ…c ryzyko bÅ‚Ä™dÃ³w ludzkich w procesie wdroÅ¼eÅ„.'
---

JakiÅ› czas temu realizowaÅ‚em w pracy bardzo ciekawy projekt. **Na podstawie nazw commitÃ³w okreÅ›laliÅ›my, jak ma byÄ‡ podbita wersja** projektu/usÅ‚ugi/komponentu. Wymaganie byÅ‚o takie, Å¼e commity musiaÅ‚y bazowaÄ‡ na <Link href="https://www.conventionalcommits.org/en/v1.0.0/" variant="primary" external>Conventional Commits</Link>, a wersja byÅ‚a na podstawie <Link href="https://semver.org/lang/pl/" variant="primary" external>Semantic Versioning</Link>.

Jest to czÄ™Å›Ä‡ czegoÅ› wiÄ™kszego. W skrÃ³cie **automatycznie podbijamy wersjÄ™ w projekcie** w zaleÅ¼noÅ›ci od tego, jak sÄ… nazwane commity zmergowane do domyÅ›lnego brancha. Potem tworzymy na podstawie tej wersji Github Release, ktÃ³re **automatycznie generuje Release Notes**, ktÃ³rymi zastÄ…piliÅ›my changelog.

Tutaj opiszÄ™, w jaki sposÃ³b za pomocÄ… **Github Actions** i prostego skryptu okreÅ›lamy podbicie wersji i dodajemy odpowiedniÄ… labelkÄ™ do **Pull Requesta** (PR). NastÄ™pny etap, czyli automatyczne podbicie wersji oraz tworzenie Github Release **poruszÄ™ w innym artykule.**

## Struktura workflow

Na poczÄ…tek potrzebujemy okreÅ›li**Ä‡, w jaki sposÃ³b wersja ma byÄ‡ podbita**. Dla commitÃ³w `fix` bÄ™dzie to semantyczny `patch`, i odpowiednio dla `feat` - `minor`, oraz dla `breaking` - `major`. WagÄ™ nowej wersji bÄ™dziemy przechowywaÄ‡ w postaci labelki do PRa, ktÃ³rÄ… teÅ¼ user bÄ™dzie mÃ³gÅ‚ sobie zmieniÄ‡ wedle uznania przed mergeâ€™em. Tutaj wÅ‚aÅ›nie dodajemy **elastycznoÅ›Ä‡** do naszej **automatyzacji**.

Technicznie stworzymy akcjÄ™ GithubowÄ…, ktÃ³ra bÄ™dzie reagowaÅ‚a na eventy z grupy `pull_request`. DziÄ™ki temu dodamy labelkÄ™ na otwarcie PRa, ale teÅ¼ na kaÅ¼dÄ… zmianÄ™, czyli nowy commit.

Sam skrypt piszÄ™ w **JavaScript**, bo ten jÄ™zyk najlepiej znam i dobrze siÄ™ sprawdza do pisania maÅ‚ych programÃ³w. Nasza akcja bÄ™dzie poczÄ…tkowo wyglÄ…daÅ‚a mniej wiÄ™cej tak:

```yaml
name: Version labels

on: [pull_request]

jobs:
  version_labels:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      repository-projects: write
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '22'
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Install @actions/core dependency
        run: npm install --no-save @actions/core
        shell: bash
      - name: Add version label
        run: node scripts/label.js ${{ github.event.pull_request.number }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
```


NajwaÅ¼niejsze tutaj to **ustalenie odpowiednich uprawnieÅ„**. Bez nich nie bÄ™dziemy mogli czytaÄ‡, ani modyfikowaÄ‡ pull requesta. Druga waÅ¼na rzecz to **przekazanie numeru pull requesta**. To na nim bÄ™dziemy bazowaÄ‡ w skrypcie.

W pierwszych krokach setupujemy Node'a, robimy checkout w repo oraz instalujemy `@actions/core`. NastÄ™pnie odpalamy nasz skrypt.

## Skrypt okreÅ›lajÄ…cy wagÄ™ podbicia wersji

PrzejdÅºmy do skryptu. Potrzebujemy **pobraÄ‡ aktualne commity** powiÄ…zane z tym PR-em. Do tego celu uÅ¼yjemy **Github CLI** oraz funkcji `exec` - najlepiej w wersji zwracajÄ…cej `Promise`. Korzystam tutaj z `exec` oraz `promisify`, ktÃ³re sÄ… natywne dla **NodeJs**. Numer PRa bÄ™dzie przychodziÅ‚ jako argument poprzez proces. Sam skrypt zamkniemy sobie w funkcji, Å¼eby byÅ‚o go Å‚atwiej testowaÄ‡.

```jsx
const core = require('@actions/core');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

const prNumberArg = process.argv[2];

async function addLabelToBasedOnCommits(prNumber) {

}

addLabelToBasedOnCommits(prNumberArg);
```

Samo pobranie danych dotyczÄ…cych PRa odbywa siÄ™ w prosty sposÃ³b poprzez Github CLI. DziÄ™ki parametrowi `--json` moÅ¼emy sobie wybraÄ‡, **jakie dokÅ‚adnie pola zostanÄ… nam zwrÃ³cone**:

```jsx
const { commits } = JSON.parse(
	(await execPromise(
		`gh pr view ${prNumber} --json commits`
	)).stdout
);
```

### OkreÅ›lanie labelki dla commit messages

Dobra, mamy commity z PRa, to teraz musimy je **przejrzeÄ‡ i zobaczyÄ‡, jakÄ… labelkÄ™ powinniÅ›my ustawiÄ‡**. Chcemy uciÄ…gnÄ…Ä‡ moÅ¼liwie najwyÅ¼szÄ… labelkÄ™ z commitÃ³w. Np. jeÅ›li mam w PRze 3 fixy, 2 featureâ€™y i jeden breaking change, to chcemy podbiÄ‡ major. Musi to byÄ‡ **niezaleÅ¼ne** od kolejnoÅ›ci commitÃ³w. 

W dalszej czÄ™Å›ci skryptu bÄ™dziemy **ustalaÄ‡ labelkÄ™ dla danego commita** i porÃ³wnywaÄ‡ jÄ… do poprzedniej. **Nie porÃ³wnujemy prefixÃ³w commita**, ale labelki, ktÃ³re wynikajÄ… z nich, poniewaÅ¼ dajemy sobie elastycznoÅ›Ä‡. ByÄ‡ moÅ¼e pÃ³Åºniej bÄ™dziemy chcieli dodaÄ‡ prefix np. `docs` lub `chore` do patcha.

W tym celu potrzebujemy prostÄ… funkcjÄ™, jak poniÅ¼sza. Po kolei sprawdzamy, czy w commit message nie ma na poczÄ…tku i przed dwukropkiem sÅ‚owa kluczowego. JeÅ›li tak, to zwracamy odpowiedniÄ… labelkÄ™.

```jsx
function getVersionLabelFromCommitMessage(commitMessage) {
    if (/^(breaking:)/.test(commitMessage)) {
        return 'major';
    }
    if (/^feat:/.test(commitMessage)) {
        return 'minor';
    }
    if (/^fix:/.test(commitMessage)) {
        return 'patch';
    }
}
```

NastÄ™pnie musimy przeiterowaÄ‡ siÄ™ po liÅ›cie commitÃ³w, Å¼eby **sprawdziÄ‡, jaka jest najwyÅ¼sza labelka**. UÅ¼ywamy metody `reduce` na tablicy, Å¼eby uzyskaÄ‡ pojedynczÄ… wartoÅ›Ä‡ z iteracji po tablicy. Prosta mapa (obiekt) pozwala nam okreÅ›liÄ‡ priorytet, czy teÅ¼ wagÄ™ labelki. 

JeÅ›li aktualnie sprawdzany commit ma wyÅ¼szÄ… labelkÄ™ niÅ¼ poprzednio wyliczona, to zwracamy wÅ‚aÅ›nie jÄ…. W innym przypadku zostajemy przy poprzedniej. Na koÅ„cu bÄ™dziemy mieli najwyÅ¼szÄ… labelkÄ™ dla danej listy commitÃ³w.

```jsx
const labelPriority = { patch: 1, minor: 2, major: 3 };

const versionLabel = commits.reduce((highestLabel, commit) => {
    const label = getVersionLabelFromCommitMessage(commit.messageHeadline);
    const isHigherPriority = labelPriority[label] >= labelPriority[highestLabel];

    return isHigherPriority ? label : highestLabel;
}, 'patch')
```

### Rozpatrywanie rÃ³Å¼nych przypadkÃ³w

Ok, wiemy juÅ¼, jakÄ… powinniÅ›my dodaÄ‡ labelkÄ™ do PRa. Pozostaje rozpatrzyÄ‡ parÄ™ przypadkÃ³w:

1. PR **nie ma Å¼adnych** labelek - po prostu dodajemy nowÄ…
2. PR ma labelki, ale **niezwiÄ…zane z wersjÄ…** - musimy to sprawdziÄ‡ i dodaÄ‡ nowÄ…
3. PR ma labelkÄ™ **zwiÄ…zanÄ… z wersjÄ…
**    a. Jest ona **niÅ¼sza** od naszej wÅ‚aÅ›nie wyliczonej - powinniÅ›my usunÄ…Ä‡ poprzedniÄ… i dodaÄ‡ nowÄ…
    b. Jest ona **rÃ³wna naszej lub wyÅ¼sza** - wtedy nie chcemy robiÄ‡ nic

Aby dodaÄ‡ labelkÄ™, potrzebujemy prostÄ… funkcjÄ™, ktÃ³ra wykona polecenie poprzez Github CLI.

<Highlight title="Uwaga" type="warning">
  Labelki muszÄ… byÄ‡ wczeÅ›niej dodane w repozytorium, aby moÅ¼na byÅ‚o je dodaÄ‡ do PRa. 
  
  MoÅ¼esz to zrobiÄ‡ rÄ™cznie albo na poczÄ…tku skryptu sprawdziÄ‡ i ewentualnie dodaÄ‡ je poprzez CLI. JeÅ›li pracujesz nad rozwiÄ…zaniem dla wielu projektÃ³w, to automatyczne dodawanie bÄ™dzie bardzo pomocne w ich wdraÅ¼aniu.
</Highlight>

Wykorzystamy tutaj `exec` â€œspromisowanyâ€, czyli taki, ktÃ³ry zwraca `Promise`, zamiast tworzyÄ‡ callback hell. Czekamy, aÅ¼ polecenie siÄ™ wykona. JeÅ›li zakoÅ„czy siÄ™ sukcesem, to dodajemy **info do logÃ³w Github Actions**. Tak pokryliÅ›my przypadek nr 1.

```jsx
async function addLabel(prNumber, newLabel) {
    await execPromise(`gh pr edit ${prNumber} --add-label ${newLabel}`);
    core.info(`Updated PR #${prNumber} with label: ${newLabel}`);
}
```

<Highlight title="Ciekawostka" type="info">
Dla zwykÅ‚ego odpalenia skryptu w terminalu lub testach `core.info` zadziaÅ‚a tak jak `console.log`.
</Highlight>

Aby przejÅ›Ä‡ do przypadkÃ³w nr 2 i 3, to potrzebujemy funkcji, ktÃ³ra **znajdzie nam najwyÅ¼szÄ… labelkÄ™ dotyczÄ…cÄ… wersji** dla danego PRa. Bardzo podobny algorytm jak w przypadku mapowania listy commitÃ³w na labelkÄ™. 

Tutaj dochodzi rÃ³wnieÅ¼ **sprawdzenie, czy labelka dotyczy w ogÃ³le wersji** projektu. DomyÅ›lna wartoÅ›Ä‡ to pusty string, wiÄ™c mamy jasnoÅ›Ä‡ co do tego, Å¼e nie znaleÅºliÅ›my Å¼adnej pasujÄ…cej labelki.

```jsx
const versionLabels = Object.keys(labelPriority);

function findHighestPriorityLabel(labelNames) {
    return labelNames.reduce((highestLabel, labelName) => {
		    const isHigherPriority = labelsMap[labelName].priority >= labelsMap[highestLabel].priority; 
        if (versionLabels.includes(labelName) && (!highestLabel || isHigherPriority)) {
            return labelName;
        }
        return highestLabel;
    }, '');
}
```

DziÄ™ki tej funkcji rozrÃ³Å¼nimy przypadek 2 i 3. Potrzebujemy jeszcze jednej funkcji, ktÃ³ra **podmieni nam labelkÄ™**. Jest bardzo podobna do `addLabel` i jÄ… teÅ¼ tutaj wykorzystujemy. Jedyne co to musimy przekazaÄ‡ parametr wiÄ™cej, czyli **labelkÄ™ do usuniÄ™cia**.

```jsx
async function replaceLabel(prNumber, currentVersionLabel, versionLabelFromCommit) {
    await execPromise(`gh pr edit ${prNumber} --remove-label ${currentVersionLabel}`);
    return addLabel(prNumber, versionLabelFromCommit)
}
```

### Struktura algorytmu

Czas wrÃ³ciÄ‡ do pierwotnego algorytmu i zaimplementowaÄ‡ te 3 przypadki. Dodajmy tu proste mapowanie labelek, Å¼eby Å‚adnie je wypisaÄ‡ w logach oraz uproÅ›ciÄ‡ algorytm w `findHighestPriorityLabel`.

```jsx
if (labels.length === 0) {
    core.info(`No labels found for PR #${prNumber}`);
    return addLabel(prNumber, versionLabelFromCommit);
}
const labelNames = labels.map(label => label.name);
core.info(`PR labels: ${labelNames.join(', ')}`);

const currentVersionLabel = findHighestPriorityLabel(labelNames);

if (!currentVersionLabel) {
    return addLabel(prNumber, versionLabelFromCommit);
}

return replaceLabel(prNumber, currentVersionLabel, versionLabelFromCommit);

```

Pozostaje nam rozrÃ³Å¼nienie jeszcze przypadku 3a oraz 3b, czyli zwaÅ¼enie poprzedniej i nowej labelki. Na tej podstawie zdecydujemy, czy podmieniaÄ‡ jÄ… czy nie. LinijkÄ™ z `replaceLabel` podmieniamy na prosty `if..else`.

```jsx
const isCurrentVersionLabelHigher = labelPriority[currentVersionLabel] >= labelPriority[versionLabelFromCommit];

if (isCurrentVersionLabelHigher) {
    core.info(`Version label not updated. Current version label is ${currentVersionLabel}`);
} else {
    return replaceLabel(prNumber, currentVersionLabel, versionLabelFromCommit);
}
```

<Highlight title="PamiÄ™taj!">
  Aby dopisaÄ‡ `labels` do argumentu polecenia pobierajÄ…cego dane o PRze oraz dodaÄ‡ je do destrukturyzacji!
</Highlight>

ZwrÃ³Ä‡ uwagÄ™ na to, Å¼e **kaÅ¼de zakoÅ„czenie skryptu jasno komunikuje userowi o jego rezultacie**. Przy edge caseâ€™ach, bÅ‚Ä™dach lub zÅ‚ym wykorzystaniu jest to kluczowe, Å¼eby dowiedzieÄ‡ siÄ™, co poszÅ‚o nie tak.

I to jest tak naprawdÄ™ koniec :) Jedyne co musimy teraz dodaÄ‡ to **sensownÄ… obsÅ‚ugÄ™ bÅ‚Ä™dÃ³w** i ewentualnie testy (nie ewentualnie - w realnym projekcie - koniecznie ;) )

### Struktura skryptu i obsÅ‚uga bÅ‚Ä™dÃ³w

CaÅ‚oÅ›Ä‡ zamkniemy sobie w `try..catch`, a w catchâ€™u ustawimy akcjÄ™ jako zakoÅ„czonÄ… niepowodzeniem. **UWAGA**! wracamy teraz do top-level funkcji. Dla Å‚atwiejszego testowania dodajemy funkcjÄ™ do `exports`, a wywoÅ‚ujemy jÄ… tylko jak skrypt jest wywoÅ‚ywany bezpoÅ›rednio przez Nodeâ€™a.

```jsx
module.exports = {
    addLabelToPRBasedOnCommits,
}

if (require.main === module) {
  try {
      addLabelToPRBasedOnCommits(prNumberArg);
  } catch (error) {
      core.setFailed(error.message);
  }
}
```

## Podsumowanie

Podsumujmy, co udaÅ‚o nam siÄ™ osiÄ…gnÄ…Ä‡. Po utworzeniu PRa oraz przy kaÅ¼dym pushu, **odpali siÄ™ workflow Version label**, ktÃ³ry **doda labelkÄ™** oznaczajÄ…cÄ… wagÄ™ podbicia wersji projektu. MoÅ¼na takiej akcji uÅ¼yÄ‡ **informacyjnie** (widaÄ‡ od razu, jaki jest rozmiar i konsekwencje zmian), albo w celu **automatycznego podbijania wersji** po zmergowaniu PRa.

<Highlight type="tip" title="Zajrzyj do kodu!">
CaÅ‚oÅ›Ä‡ rozwiÄ…zania zaimplementowaÅ‚em rÃ³wnieÅ¼ na moim blogu. Tutaj znajdziesz <Link href="https://github.com/mszkudelski/blog2.0/blob/main/.github/workflows/add-label.yml" external>workflow</Link> oraz <Link href="https://github.com/mszkudelski/blog2.0/blob/main/scripts/addLabel.cjs" external>skrypt</Link>.
</Highlight>

DowiedziaÅ‚eÅ› siÄ™ teÅ¼ w tym wpisie, **jak tworzyÄ‡ customowe akcje Githubowe** oraz jak manipulowaÄ‡ labelkami PRa. MoÅ¼e to CiÄ™ zainspiruje do tworzenia podobnych akcji, ktÃ³re przydadzÄ… siÄ™ w Twoim projekcie ğŸ™‚

OczywiÅ›cie pewnie jest duÅ¼o podobnych rozwiÄ…zaÅ„ w internecie. Jednak nie zawsze moÅ¼emy z nich korzystaÄ‡. Czasami mamy narzucone ograniczenia na przykÅ‚ad od dziaÅ‚u Security, jak to byÅ‚o w moim przypadku. **Dlatego warto wiedzieÄ‡ jak samemu zaimplementowaÄ‡ coÅ› podobnego.**

NastÄ™pny krokiem dla usera bÄ™dzie **zmergowanie PRa do domyÅ›lnego brancha, co odpali workflow, ktÃ³ry utworzy Github Release**. Na tym etapie user moÅ¼e jeszcze rÄ™cznie zmieniÄ‡ labelkÄ™ i wymusiÄ‡ inne podbicie wersji. O automatycznym tworzeniu releaseâ€™Ã³w napiszÄ™ w kolejnym artykule, wiÄ™c **Stay Tuned**! ğŸ™‚
